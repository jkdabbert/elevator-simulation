<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Elevator Simulation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white; min-height: 100vh; padding: 20px;
        }
        .container { max-width: 1400px; margin: 0 auto; }
        .header { text-align: center; margin-bottom: 30px; }
        .header h1 { font-size: 2.5rem; margin-bottom: 10px; text-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        .controls {
            background: rgba(255, 255, 255, 0.1); border-radius: 15px; padding: 20px;
            margin-bottom: 30px; backdrop-filter: blur(10px);
        }
        .control-row { display: flex; gap: 20px; margin-bottom: 15px; flex-wrap: wrap; align-items: center; }
        .control-group { display: flex; flex-direction: column; gap: 5px; }
        .control-group label { font-size: 14px; font-weight: 600; }
        .control-group input {
            padding: 8px 12px; border: none; border-radius: 5px;
            background: rgba(255, 255, 255, 0.9); color: #333; font-size: 14px; width: 120px;
        }
        .btn {
            padding: 10px 20px; border: none; border-radius: 8px; font-weight: 600;
            cursor: pointer; transition: all 0.3s ease; margin: 5px;
        }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background: #4CAF50; color: white; }
        .btn-primary:hover:not(:disabled) { background: #45a049; transform: translateY(-2px); }
        .btn-secondary { background: #2196F3; color: white; }
        .btn-secondary:hover:not(:disabled) { background: #1976D2; transform: translateY(-2px); }
        .btn-danger { background: #f44336; color: white; }
        .btn-danger:hover:not(:disabled) { background: #d32f2f; transform: translateY(-2px); }
        .simulation-area { display: flex; gap: 30px; min-height: 600px; }
        .building {
            background: rgba(255, 255, 255, 0.1); border-radius: 15px; padding: 20px;
            flex: 1; backdrop-filter: blur(10px);
        }
        .building-header { text-align: center; margin-bottom: 20px; font-size: 1.2rem; font-weight: 600; }
        .floors-container { display: flex; flex-direction: column-reverse; gap: 3px; }
        .floor {
            display: flex; align-items: center; min-height: 60px;
            background: rgba(255, 255, 255, 0.05); border-radius: 8px; padding: 10px;
            position: relative; border: 2px solid transparent;
        }
        .floor.active { border-color: #4CAF50; background: rgba(76, 175, 80, 0.2); }
        .floor-number { width: 40px; text-align: center; font-weight: bold; font-size: 18px; }
        .floor-calls { flex: 1; display: flex; gap: 10px; margin: 0 15px; }
        .call-btn {
            padding: 5px 10px; border: none; border-radius: 5px; font-size: 12px;
            cursor: pointer; transition: all 0.2s ease;
        }
        .call-up { background: #4CAF50; color: white; }
        .call-down { background: #FF9800; color: white; }
        .call-btn:hover { transform: scale(1.1); }
        .call-btn.active { box-shadow: 0 0 10px rgba(255, 255, 255, 0.5); animation: pulse 1s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .elevators-area { display: flex; gap: 10px; min-width: 200px; }
        .elevator-shaft {
            width: 80px; position: relative; background: rgba(0, 0, 0, 0.2);
            border-radius: 10px; padding: 5px;
        }
        .elevator {
            position: absolute; width: 70px; height: 50px;
            background: linear-gradient(145deg, #667eea, #764ba2); border-radius: 8px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); transition: all 0.5s ease-in-out;
            border: 2px solid transparent;
        }
        .elevator.moving { border-color: #4CAF50; box-shadow: 0 0 15px rgba(76, 175, 80, 0.5); }
        .elevator-id { font-size: 12px; font-weight: bold; margin-bottom: 2px; }
        .elevator-floor { font-size: 16px; font-weight: bold; }
        .elevator-direction { font-size: 10px; margin-top: 2px; }
        .elevator-doors {
            position: absolute; bottom: -3px; left: 50%; transform: translateX(-50%);
            font-size: 10px; padding: 2px 6px; border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
        }
        .elevator-doors.open { background: #4CAF50; color: white; }
        .status-panel {
            background: rgba(255, 255, 255, 0.1); border-radius: 15px; padding: 20px;
            width: 350px; backdrop-filter: blur(10px); max-height: 600px; overflow-y: auto;
        }
        .status-header { font-size: 1.2rem; font-weight: 600; margin-bottom: 15px; text-align: center; }
        .elevator-status {
            background: rgba(255, 255, 255, 0.05); border-radius: 8px; padding: 12px;
            margin-bottom: 10px; border-left: 4px solid #2196F3;
        }
        .elevator-status.active { border-left-color: #4CAF50; background: rgba(76, 175, 80, 0.1); }
        .status-item { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 14px; }
        .status-requests {
            margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
        }
        .console-log {
            background: rgba(0, 0, 0, 0.7); border-radius: 8px; padding: 15px; margin-top: 15px;
            max-height: 200px; overflow-y: auto; font-family: 'Courier New', monospace;
            font-size: 12px; line-height: 1.4;
        }
        .console-log .log-entry { margin-bottom: 2px; color: #00ff00; }
        .console-log .log-entry.info { color: #87CEEB; }
        .console-log .log-entry.warn { color: #FFD700; }
        .quick-actions { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255, 255, 255, 0.1); }
        .quick-actions h4 { margin-bottom: 10px; font-size: 14px; }
        .preset-btn {
            background: rgba(255, 255, 255, 0.1); color: white; border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px 12px; border-radius: 5px; cursor: pointer; margin: 2px; font-size: 12px;
            transition: all 0.2s ease;
        }
        .preset-btn:hover { background: rgba(255, 255, 255, 0.2); }
        .status-indicator {
            position: fixed; bottom: 20px; right: 20px; background: rgba(0, 0, 0, 0.8);
            color: white; padding: 15px 20px; border-radius: 10px;
            font-family: 'Courier New', monospace; font-size: 12px; min-width: 200px;
            backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); z-index: 1000;
        }
        .status-indicator.success { border-left: 4px solid #4CAF50; }
        .status-indicator.error { border-left: 4px solid #f44336; }
        .status-indicator.warning { border-left: 4px solid #FF9800; }
        .status-indicator.info { border-left: 4px solid #2196F3; }
        .status-line { margin-bottom: 3px; display: flex; justify-content: space-between; }
        .status-line:last-child { margin-bottom: 0; }
        .status-value { font-weight: bold; color: #4CAF50; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üè¢ Interactive Elevator Simulation</h1>
            <p>SCAN Algorithm with Multi-Elevator Coordination</p>
        </div>

        <div class="controls">
            <div class="control-row">
                <div class="control-group">
                    <label>Number of Elevators:</label>
                    <input type="number" id="numElevators" min="1" max="8" value="2">
                </div>
                <div class="control-group">
                    <label>Number of Floors:</label>
                    <input type="number" id="numFloors" min="3" max="50" value="10">
                </div>
                <div class="control-group">
                    <label>Speed (floors/sec):</label>
                    <input type="number" id="speed" min="0.1" max="5" step="0.1" value="1.0">
                </div>
                <div class="control-group">
                    <label>Door Time (sec):</label>
                    <input type="number" id="doorTime" min="0.5" max="5" step="0.1" value="1.0">
                </div>
            </div>
            <div class="control-row">
                <button class="btn btn-primary" onclick="buildSystem()">üèóÔ∏è Build System</button>
                <button class="btn btn-secondary" onclick="startSimulation()" id="startBtn" disabled>‚ñ∂Ô∏è Start</button>
                <button class="btn btn-secondary" onclick="pauseSimulation()" id="pauseBtn" disabled>‚è∏Ô∏è Pause</button>
                <button class="btn btn-danger" onclick="resetSimulation()">üîÑ Reset</button>
                <button class="btn btn-secondary" onclick="clearLog()">üßπ Clear Log</button>
            </div>
        </div>

        <div class="simulation-area">
            <div class="building">
                <div class="building-header">Building Floors & Call Buttons</div>
                <div class="floors-container" id="floorsContainer"></div>
            </div>
            <div class="elevators-area" id="elevatorsArea"></div>
            <div class="status-panel">
                <div class="status-header">System Status</div>
                <div id="statusContainer"></div>
                <div class="quick-actions">
                    <h4>Quick Test Scenarios:</h4>
                    <button class="preset-btn" onclick="rushHourTest()">üö∂‚Äç‚ôÇÔ∏è Rush Hour</button>
                    <button class="preset-btn" onclick="randomTest()">üé≤ Random Calls</button>
                    <button class="preset-btn" onclick="stressTest()">‚ö° Stress Test</button>
                    <button class="preset-btn" onclick="topFloorTest()">üîù Top Floor</button>
                    <button class="preset-btn" onclick="bottomFloorTest()">üîª Bottom Floor</button>
                </div>
                <div class="console-log" id="consoleLog">
                    <div class="log-entry info">üè¢ Elevator Simulation Ready</div>
                    <div class="log-entry">Click "Build System" to start</div>
                </div>
            </div>
        </div>
    </div>

    <div class="status-indicator info" id="statusIndicator">
        <div class="status-line"><span>System:</span><span class="status-value" id="systemStatus">Ready</span></div>
        <div class="status-line"><span>Elevators:</span><span class="status-value" id="elevatorCount">0</span></div>
        <div class="status-line"><span>Floors:</span><span class="status-value" id="floorCount">0</span></div>
        <div class="status-line"><span>Simulation:</span><span class="status-value" id="simulationStatus">Stopped</span></div>
    </div>

    <script>
        // Global state
        let elevatorSystem = null;
        let simulationInterval = null;
        let isRunning = false;
        let logCount = 0;
        
        const Direction = { UP: 1, DOWN: -1, IDLE: 0 };
        const DoorState = { OPEN: 'OPEN', CLOSED: 'CLOSED', OPENING: 'OPENING', CLOSING: 'CLOSING' };

        // Utility functions
        function log(message, type = 'log') {
            const consoleLog = document.getElementById('consoleLog');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            consoleLog.appendChild(entry);
            consoleLog.scrollTop = consoleLog.scrollHeight;
            
            logCount++;
            if (logCount > 50) {
                consoleLog.removeChild(consoleLog.firstChild);
                logCount--;
            }
        }

        function clearLog() {
            document.getElementById('consoleLog').innerHTML = '<div class="log-entry info">üè¢ Console cleared</div>';
            logCount = 1;
        }

        function updateStatusIndicator(status, elevators, floors, simulation, type = 'info') {
            document.getElementById('systemStatus').textContent = status;
            document.getElementById('elevatorCount').textContent = elevators;
            document.getElementById('floorCount').textContent = floors;
            document.getElementById('simulationStatus').textContent = simulation;
            document.getElementById('statusIndicator').className = `status-indicator ${type}`;
        }

        // Simple Elevator class with fixed door logic
        class SimpleElevator {
            constructor(id, minFloor, maxFloor, speed, doorTime) {
                this.id = id;
                this.minFloor = minFloor;
                this.maxFloor = maxFloor;
                this.currentFloor = 1;
                this.direction = Direction.IDLE;
                this.doorState = DoorState.CLOSED;
                this.floorRequests = [];
                this.hallRequests = [];
                this.isMoving = false;
                this.isBusy = false; // Prevent multiple operations
                this.element = null;
                
                // Timing
                this.floorTravelTime = 1000 / speed;
                this.doorTime = doorTime * 1000;
                this.stopTime = 1500;
            }

            getDirectionName(dir = this.direction) {
                return dir === Direction.UP ? 'UP' : dir === Direction.DOWN ? 'DOWN' : 'IDLE';
            }

            requestFloor(floor) {
                if (floor < this.minFloor || floor > this.maxFloor || floor === this.currentFloor) return;
                if (!this.floorRequests.includes(floor)) {
                    this.floorRequests.push(floor);
                    this.floorRequests.sort((a, b) => a - b);
                    log(`Elevator ${this.id}: Internal request for floor ${floor}`);
                }
            }

            callElevator(floor, direction) {
                if (floor < this.minFloor || floor > this.maxFloor) return false;
                if ((floor === this.maxFloor && direction === Direction.UP) ||
                    (floor === this.minFloor && direction === Direction.DOWN)) return false;
                
                const exists = this.hallRequests.find(req => req.floor === floor && req.direction === direction);
                if (!exists) {
                    this.hallRequests.push({ floor, direction });
                    log(`Elevator ${this.id}: Hall call for floor ${floor} ${this.getDirectionName(direction)}`);
                }
                return true;
            }

            getNextDestination() {
                const allFloors = new Set([...this.floorRequests]);
                this.hallRequests.forEach(req => allFloors.add(req.floor));
                
                const floors = Array.from(allFloors).filter(f => f !== this.currentFloor);
                if (floors.length === 0) return null;
                
                // SCAN algorithm
                if (this.direction === Direction.UP || this.direction === Direction.IDLE) {
                    const upFloors = floors.filter(f => f > this.currentFloor).sort((a, b) => a - b);
                    if (upFloors.length > 0) return upFloors[0];
                }
                
                if (this.direction === Direction.DOWN || this.direction === Direction.IDLE) {
                    const downFloors = floors.filter(f => f < this.currentFloor).sort((a, b) => b - a);
                    if (downFloors.length > 0) return downFloors[0];
                }
                
                // Find closest
                return floors.reduce((closest, current) => 
                    Math.abs(current - this.currentFloor) < Math.abs(closest - this.currentFloor) ? current : closest
                );
            }

            removeCompletedRequests(floor) {
                // Remove internal requests
                const idx = this.floorRequests.indexOf(floor);
                if (idx !== -1) {
                    this.floorRequests.splice(idx, 1);
                }
                
                // Remove hall requests
                this.hallRequests = this.hallRequests.filter(req => 
                    !(req.floor === floor && (req.direction === this.direction || this.direction === Direction.IDLE))
                );
                
                // Update direction
                if (this.floorRequests.length === 0 && this.hallRequests.length === 0) {
                    this.direction = Direction.IDLE;
                }
            }

            updateVisualPosition() {
                if (!this.element) return;
                
                const position = (this.maxFloor - this.currentFloor) * 63 + 10;
                this.element.style.top = position + 'px';
                this.element.querySelector('.elevator-floor').textContent = this.currentFloor;
                this.element.querySelector('.elevator-direction').textContent = this.getDirectionName();
                this.element.className = 'elevator' + (this.isMoving ? ' moving' : '');
                
                // Update doors
                const doors = this.element.querySelector('.elevator-doors');
                doors.textContent = this.doorState;
                doors.className = 'elevator-doors' + (this.doorState === DoorState.OPEN ? ' open' : '');
            }

            async processCycle() {
                if (this.isBusy) return;
                
                const destination = this.getNextDestination();
                if (!destination) {
                    this.direction = Direction.IDLE;
                    return;
                }
                
                this.isBusy = true;
                
                try {
                    // Move
                    await this.moveToFloor(destination);
                    
                    // Door sequence
                    await this.doorSequence(destination);
                    
                } catch (error) {
                    console.error(`Elevator ${this.id} error:`, error);
                } finally {
                    this.isBusy = false;
                }
            }

            async moveToFloor(targetFloor) {
                if (targetFloor === this.currentFloor) return;
                
                this.direction = targetFloor > this.currentFloor ? Direction.UP : Direction.DOWN;
                this.isMoving = true;
                
                const floorsToTravel = Math.abs(targetFloor - this.currentFloor);
                const totalTime = floorsToTravel * this.floorTravelTime;
                
                log(`Elevator ${this.id}: Moving ${this.getDirectionName()} from ${this.currentFloor} to ${targetFloor}`);
                
                // Much smoother animation with more steps
                const steps = floorsToTravel * 20; // 20 steps per floor for ultra-smooth movement
                const stepTime = totalTime / steps;
                const startFloor = this.currentFloor;
                
                // Animate each step
                for (let step = 0; step <= steps; step++) {
                    if (!this.isMoving) break; // Allow interruption if needed
                    
                    const progress = step / steps;
                    const currentVisualFloor = startFloor + (targetFloor - startFloor) * progress;
                    
                    // Update visual position in real-time
                    if (this.element) {
                        const position = (this.maxFloor - currentVisualFloor) * 63 + 10;
                        this.element.style.top = position + 'px';
                        
                        // Update floor display to show smooth progression
                        const displayFloor = Math.round(currentVisualFloor * 10) / 10; // One decimal place
                        this.element.querySelector('.elevator-floor').textContent = 
                            step === steps ? targetFloor : displayFloor.toFixed(1);
                        
                        // Update visual state
                        this.element.className = 'elevator moving';
                        this.element.querySelector('.elevator-direction').textContent = this.getDirectionName();
                    }
                    
                    if (step < steps) {
                        await new Promise(resolve => setTimeout(resolve, stepTime));
                    }
                }
                
                // Ensure we end exactly at target
                this.currentFloor = targetFloor;
                this.isMoving = false;
                
                if (this.element) {
                    const finalPosition = (this.maxFloor - targetFloor) * 63 + 10;
                    this.element.style.top = finalPosition + 'px';
                    this.element.querySelector('.elevator-floor').textContent = targetFloor;
                    this.element.className = 'elevator';
                }
                
                log(`Elevator ${this.id}: Arrived at floor ${this.currentFloor}`);
            }

            async doorSequence(floor) {
                // Open doors
                log(`Elevator ${this.id}: Opening doors at floor ${floor}`, 'info');
                this.doorState = DoorState.OPENING;
                this.updateVisualPosition();
                
                await new Promise(resolve => setTimeout(resolve, this.doorTime));
                
                this.doorState = DoorState.OPEN;
                this.updateVisualPosition();
                
                // Wait for passengers
                await new Promise(resolve => setTimeout(resolve, this.stopTime));
                
                // Remove requests
                this.removeCompletedRequests(floor);
                
                // Close doors
                log(`Elevator ${this.id}: Closing doors at floor ${floor}`, 'info');
                this.doorState = DoorState.CLOSING;
                this.updateVisualPosition();
                
                await new Promise(resolve => setTimeout(resolve, this.doorTime));
                
                this.doorState = DoorState.CLOSED;
                this.updateVisualPosition();
            }

            getStatus() {
                return {
                    id: this.id,
                    currentFloor: this.currentFloor,
                    direction: this.getDirectionName(),
                    doorState: this.doorState,
                    isMoving: this.isMoving,
                    floorRequests: [...this.floorRequests],
                    hallRequests: this.hallRequests.map(req => ({ 
                        floor: req.floor, 
                        direction: this.getDirectionName(req.direction) 
                    }))
                };
            }
        }

        // Controller
        class ElevatorController {
            constructor(numElevators, minFloor, maxFloor, speed, doorTime) {
                this.elevators = [];
                for (let i = 0; i < numElevators; i++) {
                    this.elevators.push(new SimpleElevator(i + 1, minFloor, maxFloor, speed, doorTime));
                }
                this.minFloor = minFloor;
                this.maxFloor = maxFloor;
            }

            callElevator(floor, direction) {
                // Enhanced dispatch algorithm with better load balancing
                let bestElevator = null;
                let bestScore = Infinity;
                
                log(`üéØ Dispatching call: Floor ${floor} ${direction === Direction.UP ? 'UP' : 'DOWN'}`, 'info');
                
                for (const elevator of this.elevators) {
                    let score = 0;
                    let details = [];
                    
                    // Base score: distance to requested floor
                    const distance = Math.abs(elevator.currentFloor - floor);
                    score += distance;
                    details.push(`Distance: ${distance}`);
                    
                    // Heavy penalty for busy elevators (load balancing)
                    const totalRequests = elevator.floorRequests.length + elevator.hallRequests.length;
                    const busyPenalty = totalRequests * 3;
                    score += busyPenalty;
                    if (busyPenalty > 0) details.push(`Busy penalty: +${busyPenalty}`);
                    
                    // Bonus for same direction (but not too much to avoid overloading)
                    if (elevator.direction === direction && !elevator.isBusy) {
                        score -= 1;
                        details.push(`Same direction: -1`);
                    }
                    
                    // Big bonus for completely idle elevators
                    if (elevator.direction === Direction.IDLE && totalRequests === 0 && !elevator.isBusy) {
                        score -= 5;
                        details.push(`Idle bonus: -5`);
                    }
                    
                    // Penalty for wrong direction
                    if (elevator.direction !== Direction.IDLE && elevator.direction !== direction) {
                        score += 2;
                        details.push(`Wrong direction: +2`);
                    }
                    
                    // Additional penalty for elevators that are currently moving
                    if (elevator.isMoving) {
                        score += 3;
                        details.push(`Moving penalty: +3`);
                    }
                    
                    log(`üìä Elevator ${elevator.id}: Score ${score} (${details.join(', ')})`, 'info');
                    
                    if (score < bestScore) {
                        bestScore = score;
                        bestElevator = elevator;
                    }
                }
                
                if (bestElevator) {
                    log(`üéØ Selected Elevator ${bestElevator.id} (score: ${bestScore})`, 'info');
                    return bestElevator.callElevator(floor, direction);
                }
                return false;
            }

            getSystemStatus() {
                return this.elevators.map(e => e.getStatus());
            }
        }

        // Main functions
        function buildSystem() {
            const numElevators = parseInt(document.getElementById('numElevators').value) || 2;
            const numFloors = parseInt(document.getElementById('numFloors').value) || 10;
            const speed = parseFloat(document.getElementById('speed').value) || 1.0;
            const doorTime = parseFloat(document.getElementById('doorTime').value) || 1.0;

            if (numElevators < 1 || numElevators > 8 || numFloors < 3 || numFloors > 50) {
                alert('Invalid parameters');
                return;
            }

            pauseSimulation();
            
            try {
                elevatorSystem = new ElevatorController(numElevators, 1, numFloors, speed, doorTime);
                buildFloors(numFloors);
                buildElevators(numElevators, numFloors);
                
                updateStatusIndicator('Ready', numElevators, numFloors, 'Stopped', 'success');
                document.getElementById('startBtn').disabled = false;
                log('‚úÖ System built successfully!', 'info');
                updateStatusDisplay();
                
            } catch (error) {
                log('‚ùå Build failed: ' + error.message, 'warn');
                updateStatusIndicator('Failed', 0, 0, 'Stopped', 'error');
            }
        }

        function buildFloors(numFloors) {
            const container = document.getElementById('floorsContainer');
            container.innerHTML = '';
            
            for (let floor = 1; floor <= numFloors; floor++) {
                const div = document.createElement('div');
                div.className = 'floor';
                div.id = `floor-${floor}`;
                div.innerHTML = `
                    <div class="floor-number">${floor}</div>
                    <div class="floor-calls">
                        ${floor < numFloors ? `<button class="call-btn call-up" onclick="callElevator(${floor}, 1, this)">‚Üë</button>` : ''}
                        ${floor > 1 ? `<button class="call-btn call-down" onclick="callElevator(${floor}, -1, this)">‚Üì</button>` : ''}
                    </div>
                    <div style="margin-left: 15px;">
                        ${Array.from({length: elevatorSystem.elevators.length}, (_, i) => 
                            `<button class="call-btn" style="background: #9C27B0; color: white; font-size: 10px;" 
                             onclick="requestFloor(${i+1}, ${floor}, this)">E${i+1}</button>`
                        ).join('')}
                    </div>
                `;
                container.appendChild(div);
            }
        }

        function buildElevators(numElevators, numFloors) {
            const container = document.getElementById('elevatorsArea');
            container.innerHTML = '';
            
            for (let i = 0; i < numElevators; i++) {
                const elevator = elevatorSystem.elevators[i];
                const shaft = document.createElement('div');
                shaft.className = 'elevator-shaft';
                shaft.style.height = `${numFloors * 63 + 20}px`;
                
                const elevatorDiv = document.createElement('div');
                elevatorDiv.className = 'elevator';
                elevatorDiv.innerHTML = `
                    <div class="elevator-id">E${elevator.id}</div>
                    <div class="elevator-floor">${elevator.currentFloor}</div>
                    <div class="elevator-direction">IDLE</div>
                    <div class="elevator-doors">CLOSED</div>
                `;
                
                shaft.appendChild(elevatorDiv);
                container.appendChild(shaft);
                
                elevator.element = elevatorDiv;
                elevator.updateVisualPosition();
            }
        }

        function startSimulation() {
            if (!elevatorSystem) {
                alert('Please build the system first!');
                return;
            }
            
            if (isRunning) return;
            
            isRunning = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
            
            updateStatusIndicator('Ready', elevatorSystem.elevators.length, elevatorSystem.maxFloor, 'Running', 'success');
            log('‚ñ∂Ô∏è Simulation started', 'info');
            
            simulationInterval = setInterval(runSimulationStep, 200);
        }

        function pauseSimulation() {
            if (!isRunning) return;
            
            isRunning = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            
            if (simulationInterval) {
                clearInterval(simulationInterval);
                simulationInterval = null;
            }
            
            const elevators = elevatorSystem ? elevatorSystem.elevators.length : 0;
            const floors = elevatorSystem ? elevatorSystem.maxFloor : 0;
            updateStatusIndicator('Ready', elevators, floors, 'Paused', 'warning');
            log('‚è∏Ô∏è Simulation paused', 'info');
        }

        function resetSimulation() {
            pauseSimulation();
            
            if (elevatorSystem) {
                elevatorSystem.elevators.forEach(elevator => {
                    elevator.currentFloor = 1;
                    elevator.direction = Direction.IDLE;
                    elevator.doorState = DoorState.CLOSED;
                    elevator.floorRequests = [];
                    elevator.hallRequests = [];
                    elevator.isMoving = false;
                    elevator.isBusy = false;
                    elevator.updateVisualPosition();
                });
                updateStatusIndicator('Ready', elevatorSystem.elevators.length, elevatorSystem.maxFloor, 'Reset', 'info');
            }
            
            document.querySelectorAll('.call-btn.active').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.floor.active').forEach(floor => floor.classList.remove('active'));
            
            log('üîÑ Simulation reset', 'info');
            updateStatusDisplay();
        }

        function runSimulationStep() {
            if (!elevatorSystem || !isRunning) return;
            
            // Always update visual positions for smooth animation
            elevatorSystem.elevators.forEach(elevator => {
                if (!elevator.isMoving) {
                    elevator.updateVisualPosition();
                }
            });
            
            // Process elevator logic less frequently to avoid overwhelming
            elevatorSystem.elevators.forEach(elevator => {
                if (!elevator.isBusy && (elevator.floorRequests.length > 0 || elevator.hallRequests.length > 0)) {
                    // Add small delay to prevent simultaneous processing
                    setTimeout(() => {
                        if (!elevator.isBusy) {
                            elevator.processCycle();
                        }
                    }, elevator.id * 50); // Stagger elevator processing
                }
            });
            
            updateStatusDisplay();
        }

        function updateStatusDisplay() {
            if (!elevatorSystem) return;
            
            const container = document.getElementById('statusContainer');
            const statuses = elevatorSystem.getSystemStatus();
            container.innerHTML = '';
            
            statuses.forEach(status => {
                const div = document.createElement('div');
                div.className = `elevator-status ${status.isMoving ? 'active' : ''}`;
                
                const requests = [
                    ...status.floorRequests.map(f => `F${f}`),
                    ...status.hallRequests.map(r => `${r.floor}${r.direction === 'UP' ? '‚Üë' : '‚Üì'}`)
                ].join(', ') || 'None';
                
                div.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 8px;">Elevator ${status.id}</div>
                    <div class="status-item"><span>Floor:</span><span>${status.currentFloor}</span></div>
                    <div class="status-item"><span>Direction:</span><span>${status.direction}</span></div>
                    <div class="status-item"><span>Doors:</span><span>${status.doorState}</span></div>
                    <div class="status-item"><span>Moving:</span><span>${status.isMoving ? 'üöö' : '‚èπÔ∏è'}</span></div>
                    <div class="status-requests"><strong>Requests:</strong> ${requests}</div>
                `;
                
                container.appendChild(div);
            });
        }

        // UI interaction functions
        function callElevator(floor, direction, button) {
            if (!elevatorSystem) {
                alert('Please build the system first!');
                return;
            }
            
            if (!isRunning) {
                startSimulation();
            }
            
            elevatorSystem.callElevator(floor, direction);
            
            button.classList.add('active');
            setTimeout(() => button.classList.remove('active'), 2000);
            
            const floorDiv = document.getElementById(`floor-${floor}`);
            floorDiv.classList.add('active');
            setTimeout(() => floorDiv.classList.remove('active'), 1500);
        }

        function requestFloor(elevatorId, floor, button) {
            if (!elevatorSystem) {
                alert('Please build the system first!');
                return;
            }
            
            if (!isRunning) {
                startSimulation();
            }
            
            const elevator = elevatorSystem.elevators[elevatorId - 1];
            if (elevator) {
                elevator.requestFloor(floor);
                
                button.style.background = '#4CAF50';
                button.style.transform = 'scale(1.1)';
                setTimeout(() => {
                    button.style.background = '#9C27B0';
                    button.style.transform = 'scale(1)';
                }, 1000);
            }
        }

        // Test functions
        function rushHourTest() {
            if (!elevatorSystem) {
                alert('Please build the system first!');
                return;
            }
            
            log('üö∂‚Äç‚ôÇÔ∏è Starting rush hour simulation...', 'info');
            
            if (!isRunning) {
                startSimulation();
            }
            
            // Simulate busy traffic with calls every 400ms for 20 seconds
            let callCount = 0;
            const maxCalls = 50;
            
            const rushInterval = setInterval(() => {
                const floor = Math.floor(Math.random() * elevatorSystem.maxFloor) + 1;
                const direction = Math.random() > 0.5 ? Direction.UP : Direction.DOWN;
                
                // Skip invalid directions
                if ((floor === elevatorSystem.maxFloor && direction === Direction.UP) ||
                    (floor === 1 && direction === Direction.DOWN)) {
                    return;
                }
                
                elevatorSystem.callElevator(floor, direction);
                log(`üö∂‚Äç‚ôÇÔ∏è Rush hour call ${callCount + 1}: Floor ${floor} ${direction === Direction.UP ? '‚Üë' : '‚Üì'}`, 'info');
                
                // Visual feedback
                const floorDiv = document.getElementById(`floor-${floor}`);
                if (floorDiv) {
                    floorDiv.classList.add('active');
                    setTimeout(() => floorDiv.classList.remove('active'), 1000);
                }
                
                callCount++;
                
                if (callCount >= maxCalls) {
                    clearInterval(rushInterval);
                    log('üö∂‚Äç‚ôÇÔ∏è Rush hour simulation complete', 'info');
                }
            }, 400);
            
            log(`üö∂‚Äç‚ôÇÔ∏è Simulating ${maxCalls} calls over 20 seconds...`, 'info');
        }

        function randomTest() {
            if (!elevatorSystem) {
                alert('Please build the system first!');
                return;
            }
            
            log('üé≤ Starting random test...', 'info');
            
            if (!isRunning) {
                startSimulation();
            }
            
            for (let i = 0; i < 8; i++) {
                setTimeout(() => {
                    const floor = Math.floor(Math.random() * elevatorSystem.maxFloor) + 1;
                    const direction = Math.random() > 0.5 ? Direction.UP : Direction.DOWN;
                    
                    if ((floor === elevatorSystem.maxFloor && direction === Direction.UP) ||
                        (floor === 1 && direction === Direction.DOWN)) {
                        return;
                    }
                    
                    elevatorSystem.callElevator(floor, direction);
                    log(`üé≤ Random call: Floor ${floor} ${direction === Direction.UP ? '‚Üë' : '‚Üì'}`, 'info');
                    
                    const floorDiv = document.getElementById(`floor-${floor}`);
                    if (floorDiv) {
                        floorDiv.classList.add('active');
                        setTimeout(() => floorDiv.classList.remove('active'), 1500);
                    }
                }, i * 1000);
            }
        }

        function stressTest() {
            if (!elevatorSystem) {
                alert('Please build the system first!');
                return;
            }
            
            log('‚ö° Starting stress test...', 'info');
            
            if (!isRunning) {
                startSimulation();
            }
            
            let requestCount = 0;
            
            // Call all floors simultaneously (hall calls)
            for (let floor = 1; floor <= elevatorSystem.maxFloor; floor++) {
                if (floor < elevatorSystem.maxFloor) {
                    elevatorSystem.callElevator(floor, Direction.UP);
                    requestCount++;
                }
                if (floor > 1) {
                    elevatorSystem.callElevator(floor, Direction.DOWN);
                    requestCount++;
                }
                
                // Visual feedback for each floor
                const floorDiv = document.getElementById(`floor-${floor}`);
                if (floorDiv) {
                    floorDiv.classList.add('active');
                    setTimeout(() => floorDiv.classList.remove('active'), 4000);
                }
            }
            
            // Add internal requests for all elevators to all floors
            elevatorSystem.elevators.forEach(elevator => {
                for (let floor = 1; floor <= elevatorSystem.maxFloor; floor++) {
                    if (floor !== elevator.currentFloor) {
                        elevator.requestFloor(floor);
                        requestCount++;
                    }
                }
            });
            
            log(`‚ö° Stress test: ${requestCount} total requests added!`, 'warn');
            log(`‚ö° Testing system capacity and load balancing...`, 'warn');
        }

        function topFloorTest() {
            if (!elevatorSystem) {
                alert('Please build the system first!');
                return;
            }
            
            log('üîù Testing top floor...', 'info');
            
            if (!isRunning) {
                startSimulation();
            }
            
            elevatorSystem.elevators.forEach(elevator => {
                elevator.requestFloor(elevatorSystem.maxFloor);
                log(`üîù Elevator ${elevator.id} ‚Üí floor ${elevatorSystem.maxFloor}`, 'info');
            });
            
            const topFloor = document.getElementById(`floor-${elevatorSystem.maxFloor}`);
            if (topFloor) {
                topFloor.classList.add('active');
                setTimeout(() => topFloor.classList.remove('active'), 3000);
            }
        }

        function bottomFloorTest() {
            if (!elevatorSystem) {
                alert('Please build the system first!');
                return;
            }
            
            log('üîª Testing bottom floor...', 'info');
            
            if (!isRunning) {
                startSimulation();
            }
            
            elevatorSystem.elevators.forEach(elevator => {
                elevator.requestFloor(elevatorSystem.minFloor);
                log(`üîª Elevator ${elevator.id} ‚Üí floor ${elevatorSystem.minFloor}`, 'info');
            });
            
            const bottomFloor = document.getElementById(`floor-${elevatorSystem.minFloor}`);
            if (bottomFloor) {
                bottomFloor.classList.add('active');
                setTimeout(() => bottomFloor.classList.remove('active'), 3000);
            }
        }

        // Initialize
        window.addEventListener('load', () => {
            log('üè¢ Elevator Simulation Ready!', 'info');
            log('Click "Build System" to create your configuration.', 'info');
            updateStatusIndicator('Ready', 0, 0, 'Stopped', 'info');
        });
    </script>
</body>
</html>